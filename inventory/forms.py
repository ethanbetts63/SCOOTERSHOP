# inventory/forms.py

from django import forms
from django.forms import inlineformset_factory
from django.utils.translation import gettext_lazy as _
import datetime

# Import models from the inventory app
from .models import Motorcycle, MotorcycleImage, MotorcycleCondition

class MotorcycleForm(forms.ModelForm):
    # Custom fields for estimated duration for service type (these should not be here)
    # This seems leftover from a different form or previous structure. Removing.
    # estimated_duration_days = forms.IntegerField(required=False)
    # estimated_duration_hours = forms.IntegerField(required=False)

    class Meta:
        model = Motorcycle
        fields = [
            # Condition first
            'conditions',
            # Basic motorcycle details
            'brand', 'model', 'year', 'price',
            'odometer', 'engine_size',
            # Added required fields
            'seats', 'transmission',
            # Hire rates
            'daily_hire_rate', 'weekly_hire_rate', 'monthly_hire_rate',
            # Other details
            'description', 'image',
            'is_available', 'rego', 'rego_exp', 'stock_number'
        ]
        widgets = {
            'rego_exp': forms.DateInput(attrs={'type': 'date'}),
            'conditions': forms.CheckboxSelectMultiple(attrs={'class': 'condition-checkbox-list'}),
            'daily_hire_rate': forms.NumberInput(attrs={'class': 'hire-field', 'step': '0.01'}),
            'weekly_hire_rate': forms.NumberInput(attrs={'class': 'hire-field', 'step': '0.01'}),
            'monthly_hire_rate': forms.NumberInput(attrs={'class': 'hire-field', 'step': '0.01'}),
            'seats': forms.NumberInput(attrs={'min': '1', 'max': '3'}),
            'transmission': forms.Select(attrs={'class': 'form-control'}),
        }
        # Explicitly define labels if needed, otherwise Django uses verbose_name
        # labels = {
        #     'conditions': _('Conditions (e.g., New, Used, Hire)'),
        #     'rego_exp': _('Registration Expiry Date'),
        # }

    # The title field was autogenerated in save(), no need for a form field unless editing is required
    # title = forms.CharField(required=False)
    engine_size = forms.IntegerField(min_value=0)


    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Example of setting initial values for the conditions field if migrating from an old 'condition' field
        # This logic might be specific to your migration process and can be removed once migration is complete.
        # if self.instance and hasattr(self.instance, 'condition') and self.instance.pk and not self.instance.conditions.exists():
        #     # Try to find matching condition in the new system
        #     condition_name = self.instance.condition
        #     condition = MotorcycleCondition.objects.filter(name=condition_name).first()
        #     if condition:
        #         # Set initial value for the conditions field based on the old condition
        #         self.initial['conditions'] = [condition.pk]

        # Add help text or classes to fields based on instance or other logic
        # Example: self.fields['some_field'].help_text = 'Some helpful text.'

    def clean_brand(self):
        # Capitalize the brand name
        return self.cleaned_data['brand'].capitalize() if self.cleaned_data.get('brand') else None

    def clean_model(self):
        # Capitalize the model name
        return self.cleaned_data['model'].capitalize() if self.cleaned_data.get('model') else None


    def clean_rego(self):
        # Convert registration to uppercase if it exists
        if self.cleaned_data.get('rego'):
            return self.cleaned_data['rego'].upper()
        return self.cleaned_data.get('rego')

    def clean(self):
        cleaned_data = super().clean()

        # Get selected conditions (use get() with default [] for safety)
        conditions = cleaned_data.get('conditions', [])

        # Check for specific conditions by name (case-insensitive comparison)
        condition_names = [c.name.lower() for c in conditions]

        is_new = 'new' in condition_names
        is_used = 'used' in condition_names
        is_demo = 'demo' in condition_names
        is_hire = 'hire' in condition_names

        # If hire condition is selected, daily_hire_rate is required
        if is_hire and not cleaned_data.get('daily_hire_rate'):
            self.add_error('daily_hire_rate', 'Daily hire rate is required for hire motorcycles')

        # If new, used, or demo condition is selected, price is required
        if (is_new or is_used or is_demo) and not cleaned_data.get('price'):
            self.add_error('price', 'Price is required for motorcycles listed as New, Used, or Demo')

        # Add other cross-field validation here as needed
        # Example: If condition is 'used', odometer might be required (optional based on business logic)
        # if is_used and cleaned_data.get('odometer') is None:
        #     self.add_error('odometer', 'Odometer reading is recommended for used motorcycles')


        return cleaned_data

    def save(self, commit=True):
        instance = super().save(commit=False)
        # Auto-generate title from year, brand, and model
        # Ensure year, brand, and model are available before creating title
        if instance.year and instance.brand and instance.model:
             instance.title = f"{instance.year} {instance.brand} {instance.model}"
        elif instance.brand and instance.model:
             instance.title = f"{instance.brand} {instance.model}"
        else:
             instance.title = "Untitled Motorcycle" # Fallback title

        # If we're using the new conditions field, update the old condition field
        # for backwards compatibility (first condition becomes the primary)
        # This logic might be specific to your migration process and can be removed later.
        # if 'conditions' in self.cleaned_data and self.cleaned_data['conditions']:
        #     first_condition = self.cleaned_data['conditions'].first()
        #     instance.condition = first_condition.name if first_condition else None
        # else:
        #      instance.condition = None # Clear old condition if no new conditions selected


        if commit:
            instance.save()
            # Save the m2m relations for 'conditions' field
            self.save_m2m() # Use self.save_m2m() for ModelForms
        return instance

class MotorcycleImageForm(forms.ModelForm):
    class Meta:
        model = MotorcycleImage
        fields = ['image']
        widgets = {
            'image': forms.FileInput(attrs={'class': 'form-control'}),
            # 'multiple': True # This attribute belongs on the input element, often handled by frontend or custom widget
        }

# Create a formset for multiple images
MotorcycleImageFormSet = inlineformset_factory(
    Motorcycle, MotorcycleImage,
    form=MotorcycleImageForm,
    extra=1,  # Start with 1 empty form for adding a new image
    can_delete=True,  # Allow deleting existing images
    # Specify fields explicitly for clarity, even if using form
    fields=['image'],
)