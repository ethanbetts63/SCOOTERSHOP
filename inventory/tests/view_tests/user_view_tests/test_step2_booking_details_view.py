# inventory/tests/view_tests/user_view_tests/test_step2_booking_details_view.py

import datetime
from django.test import TestCase, Client
from django.urls import reverse
from django.contrib.messages import get_messages
from unittest import mock
from decimal import Decimal
import json

from inventory.models import TempSalesBooking, InventorySettings, SalesBooking, SalesProfile
from ...test_helpers.model_factories import (
    TempSalesBookingFactory,
    InventorySettingsFactory,
    MotorcycleFactory,
    SalesProfileFactory,
)
# Assuming these utilities exist and are correctly imported in the view
from inventory.utils.get_sales_appointment_date_info import get_sales_appointment_date_info
from inventory.utils.convert_temp_sales_booking import convert_temp_sales_booking


class Step2BookingDetailsViewTest(TestCase):
    """
    Tests for the Step2BookingDetailsView.
    """

    @classmethod
    def setUpTestData(cls):
        """
        Set up common data for all tests in this class.
        """
        cls.client = Client()
        cls.url = reverse('inventory:step2_booking_details_and_appointment')

        # Ensure a singleton InventorySettings instance exists
        cls.inventory_settings = InventorySettingsFactory(
            sales_appointment_start_time=datetime.time(9, 0),
            sales_appointment_end_time=datetime.time(17, 0),
            sales_appointment_spacing_mins=30,
            max_advance_booking_days=90,
            min_advance_booking_hours=24,
            enable_viewing_for_enquiry=True, # Ensure this is true for testing viewing options
            enable_depositless_enquiry=True,
            enable_reservation_by_deposit=True,
            deposit_amount=Decimal('100.00'),
        )

        cls.motorcycle = MotorcycleFactory()
        cls.sales_profile = SalesProfileFactory()

    def _create_temp_booking_in_session(self, client, deposit_required_for_flow=False, request_viewing=False,
                                        appointment_date=None, appointment_time=None, customer_notes=""):
        """Helper to create a TempSalesBooking and set its session_uuid in the session."""
        temp_booking = TempSalesBookingFactory(
            motorcycle=self.motorcycle,
            sales_profile=self.sales_profile,
            deposit_required_for_flow=deposit_required_for_flow,
            request_viewing=request_viewing,
            booking_status='pending_details',
            appointment_date=appointment_date,
            appointment_time=appointment_time,
            customer_notes=customer_notes,
            # Ensure session_uuid is generated by factory
        )
        session = client.session
        session['temp_sales_booking_uuid'] = str(temp_booking.session_uuid)
        session.save()
        return temp_booking

    # --- GET Request Tests ---

    def test_get_no_temp_booking_id_in_session(self):
        """
        Test GET request when 'temp_sales_booking_uuid' is not in session.
        Should redirect to core:index with an error message.
        """
        response = self.client.get(self.url, follow=True)
        self.assertRedirects(response, reverse('core:index'))
        messages = list(get_messages(response.wsgi_request))
        self.assertEqual(len(messages), 1)
        self.assertEqual(str(messages[0]), "Your booking session has expired or is invalid. Please start again.")

    def test_get_invalid_temp_booking_id(self):
        """
        Test GET request with an invalid 'temp_sales_booking_uuid' in session.
        Should redirect to core:index with an error message.
        """
        session = self.client.session
        session['temp_sales_booking_uuid'] = 'a2b3c4d5-e6f7-8901-2345-67890abcdef0'  # Non-existent UUID
        session.save()

        response = self.client.get(self.url, follow=True)
        self.assertRedirects(response, reverse('core:index'))
        messages = list(get_messages(response.wsgi_request))
        self.assertEqual(len(messages), 1)
        self.assertIn("Your booking session could not be found or is invalid.", str(messages[0]))

    def test_get_no_inventory_settings(self):
        """
        Test GET request when no InventorySettings exist.
        Should redirect to core:index with an error message.
        """
        self._create_temp_booking_in_session(self.client) # Must have a temp booking for view to proceed
        InventorySettings.objects.all().delete() # Delete settings AFTER temp booking is set
        self.assertFalse(InventorySettings.objects.exists()) # Verify deletion

        response = self.client.get(self.url, follow=True)
        self.assertRedirects(response, reverse('core:index'))
        messages = list(get_messages(response.wsgi_request))
        self.assertEqual(len(messages), 1)
        self.assertEqual(str(messages[0]), "Inventory settings are not configured. Please contact support.")

        # Recreate settings for other tests
        self.inventory_settings = InventorySettingsFactory(pk=1)


    def test_get_success_deposit_flow(self):
        """
        Test successful GET request for a deposit required flow.
        Should render the form and correctly set initial 'request_viewing' to 'yes'.
        """
        temp_booking = self._create_temp_booking_in_session(self.client, deposit_required_for_flow=True)
        response = self.client.get(self.url)

        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'inventory/step2_booking_details.html')
        self.assertIn('form', response.context)
        self.assertIn('temp_booking', response.context)
        self.assertEqual(response.context['temp_booking'].session_uuid, temp_booking.session_uuid)

        form = response.context['form']
        # In deposit flow, request_viewing is forced to 'yes' internally by the form
        self.assertEqual(form['request_viewing'].value(), 'yes')
        self.assertIn('min_appointment_date', response.context)
        self.assertIn('max_appointment_date', response.context)
        self.assertIn('blocked_appointment_dates_json', response.context)
        self.assertIsNotNone(json.loads(response.context['blocked_appointment_dates_json']))


    def test_get_success_enquiry_flow(self):
        """
        Test successful GET request for an enquiry flow (no deposit).
        Should render the form and correctly set initial 'request_viewing'.
        """
        temp_booking = self._create_temp_booking_in_session(self.client, deposit_required_for_flow=False, request_viewing=True)
        response = self.client.get(self.url)

        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'inventory/step2_booking_details.html')
        form = response.context['form']
        # In enquiry flow, request_viewing can be 'yes'
        self.assertEqual(form['request_viewing'].value(), 'yes')

    def test_get_form_prefills_with_temp_booking_data(self):
        """
        Test that the form is pre-filled with existing TempSalesBooking data.
        """
        test_date = datetime.date.today() + datetime.timedelta(days=7)
        test_time = datetime.time(10, 30)
        test_notes = "Pre-existing notes for the booking."

        temp_booking = self._create_temp_booking_in_session(
            self.client,
            appointment_date=test_date,
            appointment_time=test_time,
            customer_notes=test_notes,
            request_viewing=True,
        )

        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)
        form = response.context['form']

        # Compare date objects with date objects, and time strings with time objects
        self.assertEqual(form['appointment_date'].value(), test_date) # Compare date objects
        self.assertEqual(str(form['appointment_time'].value()), test_time.strftime('%H:%M:%S')) # Django time field stores with seconds
        self.assertEqual(form['customer_notes'].value(), test_notes)
        self.assertEqual(form['request_viewing'].value(), 'yes')


    # --- POST Request Tests ---

    @mock.patch('django.contrib.messages.success')
    @mock.patch('django.contrib.messages.error')
    def test_post_no_temp_booking_id_in_session(self, mock_error, mock_success):
        """
        Test POST request when 'temp_sales_booking_uuid' is not in session.
        Should redirect to core:index with an error message.
        """
        response = self.client.post(self.url, data={}, follow=True)
        self.assertRedirects(response, reverse('core:index'))
        mock_error.assert_called_once_with(mock.ANY, "Your booking session has expired or is invalid. Please start again.")
        mock_success.assert_not_called()

    @mock.patch('django.contrib.messages.success')
    @mock.patch('django.contrib.messages.error')
    def test_post_invalid_temp_booking_id(self, mock_error, mock_success):
        """
        Test POST request with an invalid 'temp_sales_booking_uuid' in session.
        Should redirect to core:index with an error message.
        """
        session = self.client.session
        session['temp_sales_booking_uuid'] = 'a2b3c4d5-e6f7-8901-2345-67890abcdef0'  # Non-existent UUID
        session.save()

        response = self.client.post(self.url, data={'customer_notes': 'some notes'}, follow=True)
        self.assertRedirects(response, reverse('core:index'))
        mock_error.assert_called_once()
        self.assertIn("Your booking session could not be found or is invalid.", str(mock_error.call_args[0][1]))
        mock_success.assert_not_called()

    @mock.patch('django.contrib.messages.success')
    @mock.patch('django.contrib.messages.error')
    def test_post_no_inventory_settings(self, mock_error, mock_success):
        """
        Test POST request when no InventorySettings exist.
        Should redirect to core:index with an error message.
        """
        self._create_temp_booking_in_session(self.client) # Must have a temp booking for view to proceed
        InventorySettings.objects.all().delete() # Delete settings AFTER temp booking is set
        response = self.client.post(self.url, data={'customer_notes': 'test'}, follow=True)
        self.assertRedirects(response, reverse('core:index'))
        mock_error.assert_called_once_with(mock.ANY, "Inventory settings are not configured. Please contact support.")
        mock_success.assert_not_called()

        # Recreate settings for other tests
        self.inventory_settings = InventorySettingsFactory(pk=1)


    @mock.patch('django.contrib.messages.success')
    @mock.patch('django.contrib.messages.error')
    def test_post_invalid_form_data(self, mock_error, mock_success):
        """
        Test POST request with invalid form data (e.g., missing required fields).
        Should re-render the page with errors and an error message.
        """
        temp_booking = self._create_temp_booking_in_session(self.client)
        # Missing appointment_date, appointment_time, terms_accepted (required fields in form)
        post_data = {
            'customer_notes': 'Invalid data test notes',
            'request_viewing': 'yes' # If deposit_required_for_flow is False, this can be 'yes'
        }
        response = self.client.post(self.url, data=post_data)

        self.assertEqual(response.status_code, 200) # Should re-render the page
        self.assertTemplateUsed(response, 'inventory/step2_booking_details.html')
        self.assertIn('form', response.context)
        form = response.context['form']
        # These are required because request_viewing is 'yes' and enable_viewing_for_enquiry is True
        self.assertIn('appointment_date', form.errors)
        self.assertIn('appointment_time', form.errors)
        self.assertIn('terms_accepted', form.errors) # Always required
        mock_error.assert_called_once_with(mock.ANY, "Please correct the errors below.")
        mock_success.assert_not_called()

        # Ensure temp_booking was not updated
        temp_booking.refresh_from_db()
        self.assertEqual(temp_booking.customer_notes, "") # Still original empty string

    @mock.patch('django.contrib.messages.success')
    @mock.patch('django.contrib.messages.error')
    def test_post_valid_data_deposit_flow(self, mock_error, mock_success):
        """
        Test successful POST request for a deposit required flow.
        Should update TempSalesBooking and redirect to step3_payment.
        """
        temp_booking = self._create_temp_booking_in_session(self.client, deposit_required_for_flow=True)
        future_date = (datetime.date.today() + datetime.timedelta(days=7)).strftime('%Y-%m-%d')
        post_data = {
            'customer_notes': 'Customer notes for deposit booking.',
            # For deposit flow, request_viewing is forced to 'yes' by the form's __init__
            'request_viewing': 'yes',
            'appointment_date': future_date,
            'appointment_time': '10:00',
            'terms_accepted': True,
        }
        response = self.client.post(self.url, data=post_data, follow=True)

        self.assertRedirects(response, reverse('inventory:step3_payment'))
        mock_success.assert_called_once_with(mock.ANY, "Booking details saved. Proceed to payment.")
        mock_error.assert_not_called()

        temp_booking.refresh_from_db()
        self.assertEqual(temp_booking.customer_notes, 'Customer notes for deposit booking.')
        # In deposit flow, request_viewing should indeed be True
        self.assertTrue(temp_booking.request_viewing)
        self.assertEqual(str(temp_booking.appointment_date), future_date)
        self.assertEqual(str(temp_booking.appointment_time), '10:00:00')
        self.assertTrue(temp_booking.terms_accepted)

        # Ensure SalesBooking was NOT created for deposit flow yet
        self.assertEqual(SalesBooking.objects.count(), 0)
        self.assertIn('temp_sales_booking_uuid', self.client.session) # Should still be in session


    @mock.patch('django.contrib.messages.success')
    @mock.patch('django.contrib.messages.error')
    @mock.patch('inventory.utils.convert_temp_sales_booking.convert_temp_sales_booking') # Mock the utility
    def test_post_valid_data_enquiry_flow(self, mock_convert_temp_sales_booking, mock_error, mock_success):
        """
        Test successful POST request for an enquiry flow (no deposit).
        Should update TempSalesBooking, convert it to SalesBooking, and redirect to confirmation.
        """
        temp_booking = self._create_temp_booking_in_session(self.client, deposit_required_for_flow=False, request_viewing=True)
        future_date = (datetime.date.today() + datetime.timedelta(days=14)).strftime('%Y-%m-%d')

        # Mock the return value of convert_temp_sales_booking
        mock_converted_sales_booking = mock.Mock()
        mock_converted_sales_booking.sales_booking_reference = "ENQREF123"
        mock_convert_temp_sales_booking.return_value = mock_converted_sales_booking

        post_data = {
            'customer_notes': 'Enquiry notes for booking.',
            'request_viewing': 'yes',
            'appointment_date': future_date,
            'appointment_time': '14:30',
            'terms_accepted': True,
        }
        response = self.client.post(self.url, data=post_data, follow=True)

        self.assertRedirects(response, reverse('inventory:step4_confirmation')) # Corrected URL name
        mock_success.assert_called_once_with(mock.ANY, "Your enquiry has been submitted. We will get back to you shortly!")
        mock_error.assert_not_called()

        temp_booking.refresh_from_db()
        self.assertEqual(temp_booking.customer_notes, 'Enquiry notes for booking.')
        self.assertTrue(temp_booking.request_viewing)
        self.assertEqual(str(temp_booking.appointment_date), future_date)
        self.assertEqual(str(temp_booking.appointment_time), '14:30:00')
        self.assertTrue(temp_booking.terms_accepted)

        # Ensure convert_temp_sales_booking was called
        mock_convert_temp_sales_booking.assert_called_once_with(
            temp_booking=temp_booking,
            booking_payment_status='unpaid',
            amount_paid_on_booking=Decimal('0.00'),
            stripe_payment_intent_id=None,
            payment_obj=None,
        )
        # Ensure temp_sales_booking_uuid is removed from session
        self.assertNotIn('temp_sales_booking_uuid', self.client.session)
        self.assertEqual(self.client.session['current_sales_booking_reference'], "ENQREF123")


    def test_post_request_viewing_field_disabled_for_deposit_flow(self):
        """
        Test that the request_viewing field is effectively 'yes'
        when deposit_required_for_flow is True, regardless of POST data,
        and date/time are still required.
        """
        temp_booking = self._create_temp_booking_in_session(self.client, deposit_required_for_flow=True)
        future_date = (datetime.date.today() + datetime.timedelta(days=7)).strftime('%Y-%m-%d')

        # Attempt to set request_viewing to 'no' in POST data for a deposit flow, and omit date/time
        # This will test the form's logic of forcing request_viewing to 'yes' and making date/time required.
        post_data = {
            'customer_notes': 'Deposit flow with viewing attempt and missing details',
            'request_viewing': 'no', # This should be overridden by the form's internal logic
            # 'appointment_date': future_date, # OMITTED to check validation
            # 'appointment_time': '11:00',     # OMITTED to check validation
            'terms_accepted': True,
        }
        response = self.client.post(self.url, data=post_data)

        self.assertEqual(response.status_code, 200) # Should re-render with errors
        form = response.context['form']
        self.assertIn('appointment_date', form.errors) # Should be required
        self.assertIn('appointment_time', form.errors) # Should be required

        temp_booking.refresh_from_db()
        # The form's initial for request_viewing is 'yes' when deposit_required_for_flow is True
        # and the clean method ensures it is True if required.
        self.assertTrue(temp_booking.request_viewing) # Should be true due to deposit flow


        # Now, test with valid data for deposit flow, explicitly setting request_viewing to 'yes'
        post_data_valid = {
            'customer_notes': 'Deposit flow with viewing set to yes',
            'request_viewing': 'yes',
            'appointment_date': future_date,
            'appointment_time': '11:00',
            'terms_accepted': True,
        }
        response_valid = self.client.post(self.url, data=post_data_valid, follow=True)
        self.assertRedirects(response_valid, reverse('inventory:step3_payment'))
        temp_booking.refresh_from_db()
        self.assertTrue(temp_booking.request_viewing)
