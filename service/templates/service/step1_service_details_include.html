{# service/templates/service/step1_service_details_include.html #}
{% load static %}

<div class="container book-service-container">
    <div class="card has-bg-effect service-booking-card">
        <div class="card-body">
            <h2 class="section-title booking-title">Book Your Service</h2>

            <form method="post" action="{% url 'service:service_book_step1' %}" class="booking-form-container service-booking-form">
                {% csrf_token %}

                <div class="date-time-rows-group">
                    <div class="form-field service-type-field">
                        <label for="id_service_type">Service Type</label>
                        {{ form.service_type }} {# This will render the ModelChoiceField for ServiceType #}
                    </div>

                    <div class="date-time-row">
                        <div class="form-field">
                            <label for="id_dropoff_date">Drop-off Date</label>
                            <input type="text" id="id_dropoff_date" name="dropoff_date"
                                   class="form-control"
                                   placeholder="Select drop-off date"
                                   data-booking-advance-notice="{{ service_settings.booking_advance_notice|default:0 }}">
                        </div>
                        <div class="form-field">
                            <label for="id_dropoff_time">Drop-off Time</label>
                             <select id="id_dropoff_time" name="dropoff_time"
                                     class="form-control"
                                     data-start-time="{{ service_settings.drop_off_start_time|time:'H:i' }}"
                                     data-end-time="{{ service_settings.drop_off_end_time|time:'H:i' }}">
                                 <option value="">Select drop-off time</option>
                             </select>
                        </div>
                    </div>

                    <div class="search-button-column">
                        <button type="submit" class="btn-primary book-now-btn">
                            Search
                        </button>
                    </div>
                </div>

                {# Hidden fields for GET parameters to persist filters/sorting #}
                {% if request.GET %}
                    {% for key, value in request.GET.items %}
                        {% if key not in 'dropoff_date,dropoff_time,service_type' %} {# Adjusted for service booking fields #}
                            <input type="hidden" name="{{ key }}" value="{{ value }}">
                        {% endif %}
                    {% endfor %}
                {% endif %}
            </form>
        </div>
    </div>
</div>

{# Flatpickr CSS and JS are now self-contained within this include #}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/dark.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const dropOffTimeSelect = document.getElementById('id_dropoff_time');
        
        // Retrieve settings from data attributes
        const bookingAdvanceNotice = parseInt(document.getElementById('id_dropoff_date').getAttribute('data-booking-advance-notice')) || 0;
        
        // Retrieve blocked dates JSON, ensure it's safe to parse
        const blockedDatesRaw = "{{ blocked_service_dates_json|escapejs }}"; // New context variable name
        let blockedDates = [];
        try {
            blockedDates = JSON.parse(blockedDatesRaw || '[]');
        } catch (e) {
            console.error("Error parsing blocked dates JSON:", e);
        }

        const now = new Date();
        // Calculate the minimum allowed date based on booking advance notice
        let minDateForDropoff = new Date();
        minDateForDropoff.setDate(now.getDate() + bookingAdvanceNotice);
        minDateForDropoff.setHours(0, 0, 0, 0); // Start of the calculated day

        const dropOffDatePicker = flatpickr("#id_dropoff_date", {
            dateFormat: "Y-m-d",
            minDate: minDateForDropoff, // Apply minimum date
            altInput: true,
            altFormat: "F j, Y",
            // Rule: Disable dates explicitly marked as blocked.
            disable: blockedDates.map(range => ({ from: range.start, to: range.end })),
            onChange: function(selectedDates, dateStr, instance) {
                populateDropOffTimeDropdown(); // Repopulate time on date change
            }
        });

        const dropOffStartTimeAttr = dropOffTimeSelect ? dropOffTimeSelect.getAttribute('data-start-time') : null;
        const dropOffEndTimeAttr = dropOffTimeSelect ? dropOffTimeSelect.getAttribute('data-end-time') : null;

        function populateTimeDropdown(selectElement, startTimeStr, endTimeStr, intervalMinutes) {
            if (!selectElement || !startTimeStr || !endTimeStr) {
                return;
            }

            const currentValue = selectElement.value; // Store current value to re-select if valid

            // Clear existing options, keeping the first "Select time" option
            while (selectElement.options.length > 1) {
                selectElement.remove(1);
            }

            const [startHour, startMinute] = startTimeStr.split(':').map(Number);
            const [endHour, endMinute] = endTimeStr.split(':').map(Number);

            let currentTime = new Date();
            currentTime.setHours(startHour, startMinute, 0, 0);

            const endTime = new Date();
            endTime.setHours(endHour, endMinute, 0, 0);

            // Handle cases where end time is on the next day (e.g., if operational hours cross midnight, though less likely for service drop-off)
            if (endTime < currentTime) {
                endTime.setDate(endTime.getDate() + 1);
            }

            while (currentTime <= endTime) {
                const option = document.createElement('option');
                const hours = currentTime.getHours().toString().padStart(2, '0');
                const minutes = currentTime.getMinutes().toString().padStart(2, '0');
                const timeValue = `${hours}:${minutes}`;
                option.value = timeValue;
                option.text = timeValue;
                selectElement.appendChild(option);
                currentTime.setMinutes(currentTime.getMinutes() + intervalMinutes);
            }

            // Restore previously selected value if it's still valid
            if ([...selectElement.options].some(opt => opt.value === currentValue)) {
                selectElement.value = currentValue;
            } else {
                selectElement.value = ""; // Clear if current value is no longer valid
            }
        }

        function populateDropOffTimeDropdown() {
            // Populate drop-off time dropdown with full range from settings.
            populateTimeDropdown(dropOffTimeSelect, dropOffStartTimeAttr, dropOffEndTimeAttr, 15);
        }

        // Initial population of time dropdown
        if (dropOffTimeSelect && dropOffStartTimeAttr && dropOffEndTimeAttr) {
            populateDropOffTimeDropdown();
        }

        // Populate form fields from Django context if available (from TempServiceBooking)
        const initialDropOffDate = "{{ temp_booking.dropoff_date|date:'Y-m-d'|default:'' }}";
        const initialDropOffTime = "{{ temp_booking.dropoff_time|time:'H:i'|default:'' }}";
        const initialServiceType = "{{ temp_booking.service_type.pk|default:'' }}"; // Assuming PK for pre-selecting service type

        if (initialDropOffDate) {
            dropOffDatePicker.setDate(initialDropOffDate);
        }

        if (initialDropOffTime && dropOffTimeSelect) {
            if ([...dropOffTimeSelect.options].some(opt => opt.value === initialDropOffTime)) {
                dropOffTimeSelect.value = initialDropOffTime;
            }
        }

        const serviceTypeSelect = document.getElementById('id_service_type');
        if (initialServiceType && serviceTypeSelect) {
            if ([...serviceTypeSelect.options].some(opt => opt.value === initialServiceType)) {
                serviceTypeSelect.value = initialServiceType;
            }
        }
        
        // Call populateDropOffTimeDropdown again after initial data is set to ensure correct values are selected
        populateDropOffTimeDropdown(); 
    });
</script>
